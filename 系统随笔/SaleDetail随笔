at least once +幂等输出保证精确一次。
-------------------------------------------------------
购物明细:
  order_detail
         left join order_info on order_detail.order_id = order_info.id
         目的从order_info获得当前这笔订单详情的province_id和user_id,使用province_id和user_id 到对应的维度表中去关联维度信息即可。
-----------------------------------------------------------------------------------------------------------------------------
原则:
    ―、事实表的关联，只能在流中操作。原因是事实表中的事实是源源不断地产生。
    二、关联维度表时，区分所关联维度的类型:
       1.不用监控，在用的时候，直接去mysql查询即可,查询一次后，直接在App端保存:
         几乎不变(不会insert也不会update)的维度表:时间，省份地区
       2.实时监控变化:
         （1）只会新增(sku_info):当商家上架了新商品时，会向表中新增商品。但是商品的信息一旦入库禁止修改!
         （2）会变化的维度(既有insert还有update) :user_info
---------------------------------------------------------------------------------------------------------------------------------
具体实现步骤：
1.在实时的流中消费order_detail和order_info，进行关联
2.监控实时insert和update的用户信息(维度表)，将信息从Mysql同步到edis(流的批次大小5s,频繁的访问Mysql会导致大量io,导致性能低下)
  关联用户信息时，只需要查询redis即可
3.不变的维度，可以在App运行之前，一次性从mysql查询，缓存到App端。
  使用广播变量(分布式缓存)，将从Driver端广播的数据，分发到每个Executor端进行缓存。在每个Executor运行的Task都可以从Executor端读取数据。
  广播变量最大可以缓存240g的数据
 --------------------------------------------------------------------------------------------------------------------------------
 Join的条件:
(1)两个流必须从同一个StreamingContext获取
(2)只有DS[k,V]类型才能join
   order_detail
   left join order_info on order_detail.order_id = order_info.id：把on中的字段作为Key
---------------------------------------------------------------------------------------------------------------------------------------------
无法Join的根本原因:要Join的数据无法在同一个批次被消费到。
数量关系:1个order_info对N个order_detail
原则:谁早到，谁就写入缓存。|
1.对于每一个批次的order_info
  (1)和当前批次已经达到的order_detail关联
  (2)到缓存中去之前已经早到的order_detail，找到就关联
  (3)把自己写入缓存，以防后续有晚到的Order_detail
2.对于每一个批次的Order_detail
  (1)和当前批次已经达到的order_info关联。如果Order_info做过此类操作，这里可以省略
  (2)无法关联的order_detail需要读取缓存中早到的order_info，读到就关联
  (3)如果(2)读不到，说明当前的order_detail早到了，将其写入缓存。等待后续批次到达的order_info，再关联。
-----------------------------------------------------------------------------------------------------------------------------------------------
redis缓存中数据的存储:
1.order_info:
当前的需求是，对某个早到或晚到order_detail，根据order_id求订单信息
   key:orderinfo:order_id
   value: string
2.0rder_detail:
   key:orderdetail:order_id
   value: set




